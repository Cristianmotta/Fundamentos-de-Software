<!----Introducicion a css---->

# Curso de CSS Basico

Domina css para transformar idea en interfaces modernas, legibles, responsivas  y escalables con Flexbox y Grid. aplica tipografia, color y varibles para un Diseño visual consistente, y organiza ti codigo con buenas practicas que te preparan para construir proyectos web profesionales en la industria.

## Idea General del Curso

TEMAS PARA VER

+ Modela de caja: Entender cómo se define y controla el tamaño de los elementos.

+ Diseño Responsive

+ variables:Centralizar colores, tamaños y tipografías.
Evitar repetir estilos en múltiples archivos.
Cambiar un valor y actualizar toda la interfaz de forma consistente.

+ Herancia:La herencia permite que estilos del contenedor padre afecten a los hijos de forma controlada.
La especificidad ayuda a priorizar reglas y evitar “pisar” estilos por error.

+ Layouts:Usar layouts con Flexbox para distribuir y alinear elementos con flexibilidad.

+ Flexbox:Usar layouts con Flexbox para distribuir y alinear elementos con flexibilidad.

+ Grid:Emplear Grid para estructuras más complejas y responsivas. Diseñar proyectos 100 % responsive pensados desde mobile.

### Conoceremos 

+ sobre conocimientos de la variables y sitios responsive para la creacion de nuestro primer portaafolio importante para nuestra vida profesional contando bases solidas y herramientas modernas para resoveler proyectos reales.

>Profesor: Diego de Granda
>Proyecto: Un portafolio 100%
responsive listo para agregar proyectos.


---
## CSS: QUE ES CSS Y COMO APLICARLO EN HTML

css significa csacading Style sheets, hoaja de estilos en cascada que van de arriba hacia bajo. Quiere decir que los estilos se prierizan de los que estan abajo que los que estan arriba
<!--- TRES formas de colocar estilos en css --->

---

### Tres formas de css

Como le agragamos estilos a el elemento HTML?

Se hace con un sistema de atributos de atributos mediante el HTML que era una formas no tan comunes de agregar estilos en css

    <p style="color: red;">
      Soy cristian Desarrollardor de Front y Bakend
      Desarrollardor Junior  
    </p>

La segunda forma de agragar un estilo en css se pueda realizar de la sigueinte forma 

    <style>
    <!---- Segunda forma de agragar estilo --->
        h1{
            color: blue;
        }

        h2{
            color: green;
        }
    </style>

la forma mas comun y que es la mejor practica es la tercera que se realiza con una hoja que se le da la extension .css

---

Cuando quieres agregar un estilo a todo la un atributo en css se llama al Elemento de HTML para que se se vea en todo el codigo 

<img src="../img/cssimagen.png">

---

## Selectores y especificidad

selector: Es la forma en la que se llama al HTML 

Usa el inspector del navegador: clic derecho y abrir inspector para ver HTML y estilos aplicados.
Selector de etiqueta: afecta todas las etiquetas del mismo nombre.
Selector de clase: se invoca con punto y puede repetirse en varios elementos.
Selector de ID: se invoca con numeral y solo debe existir una vez.
Evita estilos en línea como práctica habitual: tienen demasiado peso y complican el mantenimiento.

>Los elementos son los estilos perce agregar un estilo a todo la un atributo en css se llama al Elemento de HTML para que se se vea en todo el codigo 

class: la clases son genericas cualquier elemento o un solo elemento solo tiene una etiqueta de la clase para modificarlo o varios pueden tener la misma clase

    <p class="parrafo"> cualquier desarrollo c++</p>
    .contenedor{
    border: 2px solid blue;
    }

id: El id es unico por por lo general lo utilizan mucho para darle una funcionalidad por eso es unico

    <p id="unico"> el id es unico c++ </p>

    #unico{
    background-color: yellow;
    }

A estos se les conoce como contenedores desendientes,
para hacer nuestro condigo solo modifique lo que esta dento de nuestro contenedor de div

    <div class="contenedor">
        <h2>Desarrolle</h2>
        <p class="parrafo"> cualquier desarrollo c++</p>
        <p id="unico"> el id es unico c++ </p>
    </div>
    .contenedor p {
     color: blue;
    }

---
#### Hover

> hover: Es cuando el mause pasa por encima de un elemeto cambia el elemento o algo puede suceder

---
## Prioridad

Prioridad de css en el estilo que se comporta de la siguiente manera: 

*Los elementos  tiene 1 puntos
*La clase tienen 10 puntos
*El id tiene 100 puntos 
*Inline Style 1000 puntos
*El !Important: Siempre gana.

Los elementos tambien tiene herencia que hereda caracteristicas a sus hijos 

    .contenedor{
     border: 2px solid blue;
     color: blue;
    }

    .contenedor p {
   
    }

Los que se herendan son los estilos de texto los demas no se heredarian ya los demas tendrias que darle su inico valor.

# ¿Cómo ser más específico: selectores descendientes y contenedores?

Los ID reescriben clases y etiquetas.
Los estilos inline y importance deben usarse con cuidado.
A mayor especificidad, más control, pero también más riesgo de conflictos.
¿Qué se hereda y qué no en CSS?
La herencia transmite estilos desde el contenedor padre a sus hijos cuando aplica a propiedades de texto.

Se heredan: color, familia tipográfica, tamaño de fuente, alineación de texto y estilos de fuente.
No se heredan: margin, padding, border, background, width, height, position.
Ejemplo de herencia.

---

# Pseudo-clases y Elementos

* Pseudo-clases: Las pseudoclases permiten apuntar a estados específicos del DOM. Un caso típico es el estado :focus en un input: cuando recibe clic o foco del teclado, puedes cambiar su estilo sin crear clases adicionales.

    input:focus{  /*Pseudo clase */}

* ¿Qué hace :focus y cómo aplicarlo? :focus estiliza el elemento enfocado.
Útil para alinear el diseño con la guía visual del producto.
Combina outline y background-color para dar feedback inmediato.

    <input type="text" placeholder="input">
    input:focus{  /*Pseudo clase */
    outline: 2px solid #3498db;
    background-color: #e8f4f8;
    }

Se aplica a todos los input cuando están en focus.
outline no altera el layout y destaca el elemento activo.

¿Cómo seleccionar elementos específicos en listas y tablas?

Cuando necesitas estilos solo en el primer o último elemento de una lista, o alternar filas en una tabla, las pseudoclases evitan crear clases manuales. Esto hace los selectores más específicos y mantenibles.

    <ul>
        <li>Primer item</li>
        <li>segundo item</li>
        <li>tercer item</li>
        <li>cuarto item</li>
    </ul>
    
    <table>
        <tr>
            <td>File 1</td>
        </tr>
        <tr>
            <td>File 2</td>
        </tr>
        <tr>
            <td>File 3</td>
        </tr>
        <tr>
            <td>Fila 4</td>
        </tr>
    </table>

    li:first-child{
    color: green;
    font-weight: bold;
    }

    li:last-child{
    color: red;
    font-weight: bold;
    }

    tr:nth-child(even) {
    background-color: gray;
    }

* Peudo-Elementos: Los pseudoelementos generan contenido que no existe en el HTML. Con ::before y ::after puedes añadir comillas u otros detalles visuales directamente desde CSS usando la propiedad content.

¿Cómo usar ::before y ::after con content?
::before y ::after se escriben con doble dos puntos.
content inserta el texto (por ejemplo, comillas) al inicio o al final.
El estilo del contenido se controla como cualquier nodo: color, tamaño, etc.

    <p class="quote">Texto con comillas</p>

    .quote::after{  
    content: '"';
    color: blue;
    font-size: 24px;
    }

    .quote::before{
    content: '"';
    color: blue;
    font-size: 24px;
    }

Lectura: https://webdesign.tutsplus.com the-30-css-selectors-you-must-memorize--net-16048t

## Box Model

Es el modelo de caja como funciona css donde toma todos los elemenetos, que es la base fundamental de como funciona css y los estilos en css

El modelo Box se utiliza para manipular los estilos existentes en los cuales utilizamos:

>Margin: es el espacio hacia fuera del contenedor

>borde: visual de donde se encuentra el contenedor.

>padding: es el espacio interno del contenedor

Box sazing: el box sazing viene por defecto del navegador 

Border Box: La buena práctica recomendada: resetear a box-sizing: border-box desde el inicio del proyecto.
Beneficio clave: control total del tamaño sin cálculos adicionales ni desbordes inesperados.

y por lo general siempre es una buena paractica resetear estos estilos para realizar un estilo mas viable para nuestra pagina.

¿Por qué hacer un reset de estilos del navegador?
Los navegadores aplican estilos por defecto que pueden alterar tu diseño. Al quitar un reset, se notan saltos porque algunos elementos traen margin y padding predefinidos por el agente del navegador.

¿Cómo afectan padding, borde y margin el tamaño?
Cuando defines un width, el cálculo del ancho total cambia según box-sizing. Con content-box, el width aplica solo al contenido y se suman padding y borde laterales al total. Con border-box, el width incluye padding y borde, así que el elemento respeta la medida establecida.

<img src="../img/frontend_developer20.png">

Todo esto es para evitar sorpresas en el layout

## Position CSS

¿Qué es position en CSS y cómo se aplica?
La propiedad position define cómo un elemento se sitúa en la página y cómo responde a top, right, bottom y left. Además, z-index controla qué elemento queda por encima cuando se superponen.

Para facilitar el ejercicio, se configuraron estilos base y selección múltiple con comas para reutilizar reglas en varios contenedores

    .contenedor,
    .contenedor-padre,
    .contenedor-scroll,
    .contenedor-zindex{
        border: 2px solid black;
        margin: 20px 0;
        padding: 10px;
    }

    .caja,
    .hijo-absolute,
    .boton-fixed,
    .elemento-sticky,
    .capa{
        border: 1px solid red;
        padding: 10px;
    }

¿Cómo funcionan relative, absolute y fixed en CSS?
Estos tres modos cambian el flujo del documento y la interacción con sus hermanos y su contenedor. Entender sus diferencias evita saltos inesperados de diseño.

¿Cuándo usar position relative con top, right, bottom, left?
Con relative, mueves el elemento desde su lugar original sin afectar el espacio que ocupaba: sus hermanos lo siguen “respetando”.
    
    .caja-relative{
        position: relative;
        top: 20px;
        left: 30px;
    }

¿Qué hace position absolute dentro de un contenedor padre?
Con absolute, el elemento sale del flujo y no reserva espacio. Se posiciona respecto al primer ancestro con position configurado (comúnmente relative en el padre).

    .contenedor-padre{
    position: relative;
    height: 100px;  
    }

    .hijo-absolute {
     position: absolute;
     top: 10px;
     right: 10px;
    }

Requiere que el padre tenga position (relative, fixed o sticky). Sus hermanos no “guardan” su espacio. Se mueve libremente dentro del padre posicionado.

¿Cómo fijar un elemento con position fixed en la pantalla?
Fixed ignora el contenedor y se ancla a la pantalla. Permite botones persistentes durante el scroll.

    .boton-fixed{
    position: fixed;
    bottom: 30px;
    right: 30px;
    }

¿Cómo se comporta sticky y cómo ordenar con z-index?
Sticky combina lo mejor de relative y fixed según el scroll. Por su parte, z-index resuelve qué capa se ve al frente cuando varias se superponen.

¿Cómo lograr un encabezado con position sticky y overflow?
Primero, crea un contenedor con scroll propio y luego fija el elemento cuando toque el borde indicado.

    .contenedor-scroll{
    height: 150px;
    overflow-y: auto;
    }

    .elemento-sticky{
    position: sticky;
    top: 0px;
    }

¿Cómo controlar el orden visual con z-index y capas?
Define un contexto posicionado en el contenedor y usa z-index en elementos absolute para controlar qué queda delante.

    .contenedor-zindex{
        position: relative;
        height: 150px;
    }

    .capa {
        position: absolute;
        width: 80px;
        height: 80px;
    }

    .capa-1{
        top: 20px;
        left: 20px;
        background-color: blue;
        z-index: 1;
    }

    .capa-2{
        top: 40px;
        left: 40px;
        background-color: red;
        z-index: 2;
    }

    .capa-3{
        top: 60px;
        left: 60px;
        background-color: green;
        z-index: 3;
    }

# Organizacion Bem

La organizacion ben evita que nuestro codigo de css se ponga encima de otro cuando el codigo es mucho mas extenso

BEM significa block, element y modifier. La idea central: cada clase indica su rol y alcance. Un bloque agrupa una pieza independiente de interfaz; un elemento es una parte del bloque; un modificador expresa un estado o variante.

    <div class="card">
        #Elemntos
        <h2 class="card__title">Laptop Pro</h2>
        <p class="card__price">$999</p>
        <button class="card__button">Comprar</button>
         
        <button class="card__button card__button--disabled">Sin Stock</button>
        #Modificardor 
    </div>

Bloque: representa un componente como una tarjeta, por ejemplo, card.
Elemento: se nombra con doble guion bajo: card__title, card__price, card__button, card__badge.
Modificador: se nombra con doble guion: card--feature, card__button--disable.
Así se evita que estilos globales se mezclen: cada selector apunta a un contexto específico.

¿Cómo se estructura un bloque, elemento y modificador?
Bloque independiente: card agrupa borde, padding y tamaño máximo.
Elementos internos: card__title, card__price, card__button y card__badge heredan el contexto de card.
Modificadores: --feature para destacar la tarjeta y --disable para estados del botón.
¿Cómo nombrar clases con BEM en una tarjeta card?
La tarjeta funciona como bloque principal. Dentro, se definen elementos para el título, el precio, los botones y un badge. Luego se aplican modificadores para estados específicos.

Borde visible para distinguir componentes.
Padding interno uniforme.
Margin-bottom para separar tarjetas.
Max-width para controlar el crecimiento.
¿Cómo estilizar los elementos title, price y button?
Se aplican estilos puntuales a cada elemento, sin afectar otros bloques.

    .card__title {
     color: #333;
     margin-bottom: 50px;
    }

    .card__price {
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 25px;
    }

    .card__button {
    padding: 10px 20px;
    background-color: #333;
    color: white;
    border: none;
    cursor: pointer;
    margin-right: 5px;
    }

Señal visual clara con contraste.
Tamaño compacto y legible.
¿Cómo usar modificadores para estados como feature y disable?
Los modificadores expresan variaciones: uno para el bloque completo (feature) y otro para el botón deshabilitado (disable). Separar estado de estructura mantiene el CSS limpio y predecible.

.card--feature {
  border-color: gold;
  border-width: 3px;
}
Visual más prominente sin romper la consistencia.
Reutilización del bloque con mínimos cambios.
¿Cómo comunicar un botón deshabilitado con card__button--disable?
El estado de “no permitido” se refleja en color y cursor.

.card__button--disable {
  background: grey;
  cursor: not-allowed;
}

## Unidades de medida

Elegir la unidad correcta en CSS es clave para lograr un diseño responsive, accesible y controlado. Aquí se explica, con ejemplos claros, cuándo usar px, %, rem, em, vw y vh, sus ventajas y sus límites en contenedores y texto. Además, verás por qué rem mejora la accesibilidad y cómo vw/vh simplifican ocupar toda la pantalla.

¿Cómo usar porcentajes para contenedores flexibles?
El porcentaje se calcula con base en el contenedor padre. Si ese padre tiene dimensiones, tu caja puede adaptarse. Por ejemplo, 50% tomará la mitad del ancho disponible del padre, y se mantendrá proporcional al redimensionar la ventana.

tipos de unidades de medida en css 

El pixel es la unidad de medida fija cuando le das un tamaño a un contenedor solo le das una unidad de medida fija.

    .box-pixel {
        border: 1px solid red;
        padding: 16px;
        width: 200px;
    }

Depende del tamaño del contenedor padre.
Permite contenedores flexibles y relativos.
Requiere que el padre tenga dimensiones definidas.
Ejemplo:

    .box-percent {
        border: 1px solid red;
        padding: 16px;
        width: 50%;
    }

cuando quieres pasar a tablet o movil los pixeles te pueden jugar una mala pasada el porcentaje es la opcion mas vieble para ese tipo de tamaños 

Rem es bueno para utilizarlos en las funtes pero para las mediadas no es tan bueno: 1 rem es igual a 16px

1 em es igual 16px la diferencia de rem si le agrgamos on font-zice crece el font-zice y crece el contenedor por eso es mejor utilizar el rem por uqe cambia el tamñano de la fuente 


VW sera el procentaje de pantalla que sera 30% del ancho de la pantalla

    .box-vw {
        border: 1px solid red;
        padding: 16px;
        width: 30vw;
    }

vh sera el alto de la pantalla que 30% del alto de la pantalla 
    .box-vh {
        border: 1px solid red;
        padding: 16px;
        height: 20vh;
    }

¿Qué diferencias hay entre rem, em, vw y vh?
Estas unidades relativas resuelven necesidades distintas. rem y em se basan en el font-size; vw y vh usan el tamaño del viewport. Elegir bien evita comportamientos inesperados y mejora la accesibilidad.

Habilidades que practicas aquí: - Definir dimensiones con px, %, rem, em, vw y vh según el objetivo. - Usar el inspector para verificar comportamientos en diferentes tamaños de pantalla. - Priorizar rem para tipografías y medidas previsibles; evitar acumulación indeseada de em. - Aplicar vw/vh para bloques adaptados al viewport, como un hero a pantalla completa.

## Proyecto final

segun lo realizado en la clase de fundamentos de css realizamos un pequeño portafolio donde se muestra todo lo aprendido por el momento

<img src="../img/proyecto.png" >

## Fuentes Web

Elegir y configurar fuentes web en CSS define la legibilidad y el estilo de una interfaz. Aquí aprenderás a usar familias tipográficas del navegador, crear un font stack con fallback confiable y cargar tipografías de Google Fonts como Poppins e Inter, con pesos y variaciones bien seleccionados para títulos y textos.


 Fuentes y la legibilidad 
---

Funtes especificas y como modificarlas de diferentes maneras 

Existen 5 familias especificas de Fuentes

Serif: con “decoraciones” al final de los trazos. Ejemplo típico: Times New Roman. Da un aire clásico y editorial.
Sans-serif: sin decoraciones. Ejemplos comunes: Arial, Helvetica. Se percibe más limpia y moderna.
Monospace: ancho fijo en cada carácter. Ideal para mostrar código.
Cursive: simula escritura a mano.
Fantasy: más decorativa y expresiva.

Como utilizar las fuentes en css:

    .serif{
        font-family: serif;
        font-size: 20px;
    }

    .sans-serif{
        font-family: sans-serif;
        font-size: 20px;
    }

    .monoespace{
        font-family: monospace;
        font-size: 20px;
        background: #f0f0f0;
        padding: 5px;
    }   

    .google-title{
        font-family: "Popins", sans-serif;
    }

    .google-text{
        font-family: "Itern", sans-serif;
    }

## Fall back

las fuentes en los navegadores pueden ser modificadas o verificar que tipo de funtes que tiene en existencia el navegador y si es un nuestra el navegador la interpreta y la guarda 

Si quieres utilizar otro y tipo de fuentes 
podemos utilizar:

* FONTS-GOOGLE.COM

Recomendacion utiliza siempre dos tipos de fuentes diferentes.

Importate!
---

> Buena práctica: termina el stack con una familia genérica. Garantiza renderizado consistente si falla la fuente primaria.

> Compatibilidad: algunas fuentes existen solo en ciertos sistemas (Mac OS o iOS) y no en Windows. El fallback evita inconsistencias.

> Confiabilidad: si se cae el servicio de fuentes, el fallback entra sin romper el diseño.


## Propiedades Tipográficas

Mejora la legibilidad y accesibilidad dominando las propiedades tipográficas de CSS: font-size con rem, font-weight, line-height y font-style. Con pequeños ajustes, el texto se vuelve más claro, cómodo y consistente en distintos dispositivos. Aquí verás cómo aplicar estos cambios con clases simples como normal, light, bold, compact, space e italic.

las propiedades son las que ayudan a modificar las funtes.

Font-size: Tamaño de letra el 1rem se adapta al tamaño de las pantallas


font weight: Grosor de 100 a 400 no se nota ningun cambio de 500 a 900 es como tener un bold

    .light {
        font-weight: 300;
    }

    .bold {
        font-weight: 900;
    }

line-height: Altura de interlinea puedes darle un 'aire' al espacio de los parrafos
o lineas que hay entre parrafos

    .compact {
        line-height: 1;
    }

    .space {
        line-height: 2;
    }


font-style: darle un estilo unico a nuestra fuente 

.italic {
  font-style: italic;
}

.oblique {
  font-style: oblique;
}

.normal {
  font-style: normal; /* valor por defecto */
}

## Control de Texto

¿como controlo mi texto en HTML?
Cuando queremos hacer un desarrollo web queremos realizar un desarrollo, necesitamos colocar nuestro texto de forma adecuada para esto funciona.

Controla tu tipografía con precisión usando propiedades clave de CSS para alinear, transformar, decorar e indentar texto. Aquí verás cómo aplicar text-align, text-transform, text-decoration y text-indent de forma clara, con ejemplos prácticos y consideraciones de maquetación.

¿Cómo alinear texto con CSS sin complicaciones?
La alineación define la posición del contenido dentro de su contenedor. Por defecto, los párrafos se alinean a la izquierda y ocupan el 100 % del width disponible. Con la propiedad text-align puedes usar valores como left, center, right y justify para lograr el resultado deseado. El centrado funciona mientras el contenedor tenga espacio; si no, necesitarás otras técnicas de maquetación.

> Left: alineación por defecto a la izquierda.
> Center: centra el texto dentro del ancho disponible.
> Right: empuja el texto hacia la derecha.
> Justify: distribuye espacios para ocupar el ancho completo en cada línea.
Nota: justify ajusta los espacios entre palabras en líneas con suficiente contenido. Si una línea tiene pocas palabras, no forzará espacios excesivos.

* .uppercase { text-transform: uppercase; }
* .lowercase { text-transform: lowercase; }
* .capitalize { text-transform:   capitalize; }
* Uppercase: convierte todo a mayúsculas.
* Lowercase: transforma a minúsculas.
* Capitalize: pone en mayúscula la letra 
inicial de cada palabra.

Estas opciones ayudan a mantener consistencia tipográfica según el tono o la formalidad del contenido.

## Aplicacion de fuentes de Google y estilos Css al protafolio

a

---

## sistemas de color

Domina cómo aplicar color en CSS con hexadecimal, RGB, HSL, alfa (RGBA) y nombres de color. Verás cómo estos sistemas controlan el background-color, el texto y los bordes, con ejemplos claros para evitar dudas comunes y lograr tonos exactos

Formatos de colores en css

* Hexadecimal (#RRGGBB): valores 0–9 y A–F. Dos dígitos por canal. Empieza con numeral. 000000 es negro. FFFFFF es blanco.  

* RGB (rgb(r, g, b)): tres valores del 0 al 255 por canal. 0 apaga el canal, 255 lo lleva al máximo.

* HSL (hsl(h, s%, l%)): tono en grados 0–360, saturación 0–100 %, luminosidad 0–100 %.


* Alfa (rgba): cuarto valor 0–1 para transparencia. 1 es sólido; 0, totalmente transparente.

/* Blanco y negro. */
.box-blanco { background-color: #FFFFFF; }
.box-negro  { background-color: #000000; }

/* Rojo con combinación alta en R y valores menores en G y B. */
.box-rojo   { background-color: #FF5733; }
Claves prácticas: - Empieza con #. Siempre seis dígitos. - FF es el máximo del canal. 00 es el mínimo.

¿Qué hacen rgb y rgba con el color y la transparencia?
En rgb(r, g, b) cada canal va de 0 a 255. Es muy directo para ajustar intensidad por canal y es como se renderizan las imágenes en el navegador: píxel a píxel combinando RGB.

/* Primarios. */
.box-negro  { background-color: rgb(0, 0, 0); }
.box-rojo   { background-color: rgb(255, 0, 0); }
.box-verde  { background-color: rgb(0, 255, 0); }
.box-azul   { background-color: rgb(0, 0, 255); }

/* Azul verdoso medio tenue. */
.box-azul-tenue { background-color: rgb(52, 152, 219); }
Con rgba(r, g, b, a) agregas el alfa para transparencia del 0 al 1.

/* Sólido. */
.box-solida { background-color: rgba(231, 76, 60, 1); }
/* Media transparencia. */
.box-media  { background-color: rgba(231, 76, 60, 0.5); }
/* Más tenue. */
.box-tenue  { background-color: rgba(231, 76, 60, 0.25); }
Pautas rápidas: - Alfa en 1: color 100 % sólido. - Alfa en 0.5: semítransparente. - Alfa en 0.25: muy tenue.

¿Cómo leer y ajustar hsl con tono, saturación y luminosidad?
En hsl(h, s%, l%): - h es el tono en grados 0–360. Se recorre por los principales: del 0 hacia rangos cercanos se perciben rojos; más adelante verdes; después azules. - s es saturación en %: 0 % da grises, 100 % da color puro. - l es luminosidad en %: 0 % es negro, 50 % color “normal”, 100 % blanco.

/* Rojo con saturación media y luminosidad media. */
.box-hsl { background-color: hsl(0, 50%, 50%); }
Nota sobre nombres de color: también puedes declarar colores por nombre cuando necesitas rapidez en background-color o color de texto.

.titulo { color: green; }
.destacado { background-color: gold; }
¿Qué habilidades y conceptos clave practicar?
Potencia tu dominio con estas prácticas. Te darán control fino del color según el contexto de diseño y accesibilidad.

## Variables CSS

son importantes cuando un proyecto empieza a ser muy grandes 
y nos ayuda a tener un orden de los colores que debe tener nuestra pagina para no replicar los colores en cada linea si no directamente en desde la variable

los seudo selectores llamado root que es igual a html pero con mayor especificidad algunas varbalas son locales y otras son globales  por lo general necesitamos las globales 

    :root{
        ---color-primary: #3498db;
        ---color-secondary: #2ecc71;
        ---color-denger: #e74c3c;
        ---color-dark: #2c3e50;
        ---color-light: #ecf0f3;
        ---space: 20px;
    }

* ¿Por qué usar variables CSS para escalar proyectos?: Las variables permiten definir un valor una sola vez y reutilizarlo en todo el CSS. Así evitas copiar y pegar, mantienes una línea visual coherente y haces cambios globales en segundos. Si diseño cambia la paleta, editas la variable y todo se actualiza de forma automática.

* Reducen repetición de estilos y errores humanos.
Mantienen colores y fuentes consistentes.
Hacen cambios globales desde un solo lugar.
Mejoran el mantenimiento y tu salud mental.
¿Qué problemas resuelven las variables CSS?
Botones repetidos con el mismo background, padding y margin.
Discrepancias por recordar mal un color o una fuente.
Dificultad para actualizar paletas o espacios en muchos componentes.

* ¿Cómo declarar y usar variables con :root y var?
El pseudoselector :root actúa como un contenedor global con mayor especificidad que html. Define ahí variables para que todo el documento pueda usarlas. La sintaxis: dos guiones, nombre y valor; luego consume con var().


## Degradados

¿Cómo preparar los contenedores con CSS para degradados?
Para que los degradados se aprecien bien, primero se definen estilos comunes en los contenedores div. La idea: usar el background del elemento como lienzo del degradado y asegurar buena legibilidad del texto.

Tamaño base: width 200px y height 100px.
Espaciado: margin 10px y padding 20px.
Legibilidad: color blanco.
Distribución: display en inline-block para que se ubiquen en línea con propiedades de bloque.
Alineación: text-align center y line-height 60px para centrar el texto.
    .demo {
        width: 200px;
        height: 100px;
        margin: 10px;
        padding: 20px;
        color: #fff;
        display: inline-block; /* en línea, con propiedades de bloque */
        text-align: center;
        line-height: 60px;
    }


¿Qué es un linear-gradient simple?
Por defecto, dirección vertical (arriba a abajo).
Colores: azul #3498DB hacia morado #9B59B6.
.linear-simple {
  background: linear-gradient(#3498DB, #9B59B6);
}
¿Cómo cambiar la dirección a la derecha?
Se define la dirección con palabras clave.
Dirección: to right.
Colores: rojo #E74C3C hacia amarillo/naranja #F39C12.
.linear-direction {
  background: linear-gradient(to right, #E74C3C, #F39C12);
}
¿Cómo trazar un degradado diagonal?
Dirección diagonal: to bottom right.
Colores: verde claro #2ECC71 hacia azul #3498DB.
.linear-diagonal {
  background: linear-gradient(to bottom right, #2ECC71, #3498DB);
}
Puntos clave: - Dirección controlada con palabras como to right o to bottom right. - Fusión suave entre colores con resultados limpios.

¿Cómo usar radial-gradient y múltiples colores?
Un degradado radial crea transiciones circulares desde un punto. Se puede definir la forma del círculo y su posición inicial. Además, los degradados admiten múltiples colores para efectos como arcoíris.

¿Cómo crear un radial-gradient simple?
Forma: circle.
Colores: del amarillo/naranja #F39C12 al rojo #E74C3C desde el centro.
.radial-simple {
  background: radial-gradient(circle, #F39C12, #E74C3C);
}

¿Cómo posicionar el centro del gradiente radial?
Posición del centro con at.
Posición: at top left.
Colores: rojo #E74C3C hacia azul #3498DB.
.radial-position {
  background: radial-gradient(circle at top left, #E74C3C, #3498DB);
}

¿Cómo aplicar múltiples colores en un degradado lineal?
Dirección: to right.
Colores: red, orange, yellow, green, blue.
.multiple {
  background: linear-gradient(to right, red, orange, yellow, green, blue);
}

Buenas prácticas y usos: - Backgrounds de secciones como heroes o contenedores. - Contraste: texto blanco para máxima legibilidad. - Escalabilidad: combinar dirección y posición según el diseño.

¿Te gustaría compartir qué combinación de colores usarías y en qué tipo de sección la aplicarías?


## Sombras y Bordes

Se utilizan las sombras y los bordes para darle un estilo difirente a nuestro contenedores.

Cómo preparar estilos base para contenedores en CSS?
Antes de aplicar sombras y bordes, conviene definir estilos consistentes para los elementos que usarás. Aquí se trabaja con div y la etiqueta p para que se comporten como tarjetas simples.

Usa display: inline-block para que, si hay espacio, se coloquen en línea.
Define padding y margin para separar contenido y elementos.
Fija background: white para evitar transparencias indeseadas.
Limita el encogimiento con min-width: 100px.
Centra el texto con text-align: center.

    div, p {
        display: inline-block;
        padding: 20px;
        margin: 10px;
        background: #fff;
        min-width: 100px;
        text-align: center;
    }

¿Qué conceptos clave aplicas aquí?
display: inline-block: coloca cajas en línea respetando dimensiones.

padding y margin: espaciado interno y externo.
background: buena práctica para visibilidad consistente del contenedor.

min-width: evita que el contenido colapse más allá de un mínimo.
text-align: center: alinea el texto al centro del contenedor.
¿Cómo aplicar y ajustar box-shadow e inset?
La sombra de caja agrega profundidad a contenedores. Se compone de desplazamiento horizontal, desplazamiento vertical, difuminado (blur), expansión (spread) y color. Un error común: no se usan comas entre valores de box-shadow.

Define primero una sombra simple con desplazamientos y color.
Usa el inspector del navegador para debuggear y ajustar en vivo.
Ajusta blur para difuminar y spread para expandir la sombra.
Aplica inset si deseas una sombra interna.

    /* Sombra externa simple */
    .shadow-simple {
      box-shadow: 5px 5px gray;
    }

Si necesitas una sombra interna, antepone inset y agrega el difuminado.

    /* Sombra interna (inset) con difuminado */
    .shadow-inset {
        box-shadow: inset 0 0 10px gray;
    }

¿Qué ajustes hacer con el inspector del navegador?
Arrastra el widget de sombras para explorar X e Y.
Incrementa blur para una sombra más realista.
Modera spread para evitar bordes exagerados.
Copia los valores finales y pégalos en tu CSS.
¿Cómo crear sombras de texto y bordes redondeados efectivos?
El texto también puede beneficiarse de una sombra sutil. Y con bordes redondeados, tus contenedores se sienten más amables y modernos, ideales para “tarjetas”.

¿Qué ajustes mejoran una text-shadow legible?
Usa desplazamientos moderados para no perder legibilidad.
Aplica un blur equilibrado para suavizar sin deformar.
Mantén un color gris tenue para no competir con el contenido.

    /* Sombra de texto sutil */
        .text-shadow {
        text-shadow: 2px 2px 5px gray;
    }

¿Cómo redondear bordes con border-radius?
Define un borde discreto y redondea esquinas.
Combina border-radius con box-shadow para un efecto de tarjeta.
    /* Tarjeta con borde y esquinas suaves */
    .radius-small {
        border: 2px solid #333;
        border-radius: 5px;
    }

Para lograr un círculo (ideal para avatares), usa border-radius: 50% y define ancho y alto iguales.

    /* Convertir en círculo */
    .radius-small {
        width: 100px;
        height: 100px;
        border-radius: 50%;
    }
    Si prefieres esquinas más marcadas, cambia el radio a 15px.

/* Esquinas más redondeadas */
    .radius-small {
        border-radius: 15px;
    }

## Introduccion a Flexbox

Nos ayuda a posionar los conteneidos en contenedores para dorle un orden a nuestro contenedores 

    .container {
        display: flex; /* Activa el modelo de Flexbox */
        background: #f0f0f0; /* background gris claro */
        padding: 10px; /* espacio interno */
        margin-bottom: 20px; /* separación entre  contenedores */
        min-height: 100px; /* altura mínima del   contenedor */
    }

Idea clave: al pasar de display: block a display: flex, el layout cambia y puedes usar propiedades flex para alinear y distribuir con precisión.

¿Cómo se estiliza el contenedor y los items con CSS?
Se distinguen el contenedor y los elementos internos para visualizar mejor el comportamiento. Así se entiende dónde actúa cada propiedad.

Los elementos internos son items (por ejemplo, divs con números).
Se usa un background visible y separación entre elementos.
El texto se centra con text-align y se mejora la legibilidad con padding.

    .item {
        background: #3498db; /* azul para diferenciar */
        color: white; /* contraste del texto */
        margin: 5px; /* separación entre items */
        text-align: center; /* centra el texto en el item */
        padding: 20px; /* espacio interno del     item */
    }

Habilidades que desarrollas: reconocer el rol del contenedor frente a los items, aplicar padding, margin, min-height y colores para inspeccionar y depurar el layout.

¿Cómo funcionan flex-direction, justify-content y align-items?
Con display: flex activo, el siguiente paso es controlar la dirección, la distribución y la alineación. Estas tres propiedades cubren la mayoría de casos cotidianos de alineación en CSS.

¿Qué hace flex-direction en el eje principal?
Define la dirección del eje principal del contenedor flex.

    .column {
        display: flex;
        flex-direction: column; /* apila los      items en columna */
    }

Cambia de fila (por defecto) a columna con column.
Útil cuando quieres que los items ocupen el 100% a lo largo del eje vertical.
Permite pensar en eje principal (horizontal o vertical) y eje transversal.
¿Cómo centrar con justify-content en el eje principal?
Controla la alineación y distribución a lo largo del eje principal del contenedor.

    .center {
        display: flex;
        justify-content: center; /* centra                            los   items en el eje principal */
    }


Centra horizontalmente si el eje principal es una fila.
Centra verticalmente si usas flex-direction: column.
Palabras clave frecuentes: flex-start, center, flex-end, space-between, space-around.
¿Cómo alinear con align-items en el eje transversal?
Alinea los items en el eje transversal del contenedor.

    .align {
        display: flex;
        align-items: center; /* centra los items en el eje transversal */
    }

Centra de arriba a abajo cuando el eje principal es horizontal.
Responde al tamaño del contenedor padre (por ejemplo, min-height: 100px).
Antes era complejo; ahora basta una línea con Flexbox.
Conceptos que dominas al practicar: - Contenedor vs items: dónde aplicar cada propiedad. - Eje principal y eje transversal: base mental de Flexbox. - Centrado real con justify-content y align-items sin hacks.

## Flexbox Avanzado

¿Cómo configurar el contenedor y los items en Flexbox?
Para activar el modelo de Flexbox, el primer paso es convertir el contenedor en un contexto flexible con display: flex. Así se habilitan las propiedades que permiten distribuir y alinear los elementos internos de forma eficiente. También se aplica min-height: 100px para asegurar una altura mínima, y se usa margin-bottom y padding para separar y dar aire visual.

    .container {
        display: flex;
        min-height: 100px;
        /* margin-bottom: ...; */
        /* padding: ...; */
        /* background: ... (gris utilizado previamente) */
    }

¿Cómo se centra el texto dentro del item?
Cada elemento dentro del contenedor es un item. Para centrar su contenido horizontalmente se usa text-align: center. Además, se aplica padding para generar espacio interno, margin para separación entre tarjetas, un background azul y color: white para contraste.

    .item {
        text-align: center;
        padding: 20px;
        margin: 5px;
        background: #3498db;
        color: white;
    }

Activar contexto flexible con display: flex.
Asegurar altura mínima con min-height: 100px.
Separar bloques con margin-bottom y dar aire con padding.
Centrar texto con text-align: center.
¿Cómo hacer que los elementos crezcan con flex-grow y flex?
Cuando hay espacio libre en el contenedor, flex-grow permite que los items crezcan para ocuparlo. Así controlas la proporción de crecimiento entre elementos vecinos de forma simple.

¿Qué hace flex-grow 0, 1 y 2?
0: no crece para ocupar espacio extra.
1: crece proporcionalmente al resto que también tiene 1.
2: crece el doble respecto a los que tienen 1.

    .grow { /* aplicado al elemento con clase correspondiente */
     flex-grow: 1;
    }

Ejemplo de uso: si un item tiene .grow con flex-grow: 1, ocupará espacio libre; si otro tiene valor 2, crecerá el doble que el de 1.

¿Cuándo usar el shorthand flex?
El atajo flex agrupa varias configuraciones en una sola línea. En el ejemplo, flex: 1 se comporta como el crecimiento proporcional visto con flex-grow.

    .flex.uno { /* elemento con clases: flex y uno */
    flex: 1;
    }

    .flex.dos { /* elemento con clases: flex y dos */
     flex: 2;
    }
    flex: 1 hace que el item crezca para ocupar el espacio disponible.
    flex: 2 crece el doble que los que tienen flex: 1.


Útil cuando quieres definir crecimiento de manera breve y consistente.
¿Cómo alinear contenido con align-self?
Para alinear items de forma independiente, align-self permite posicionarlos en el eje cruzado. Con flex-start se sitúan arriba y con flex-end abajo. El alto visible se adapta al contenido y al padding aplicado.

    .self.start { /* elemento con clases: self y start */
    align-self: flex-start;
    }

    .self.end { /* elemento con clases: self y end */
        align-self: flex-end;   
    }

align-self: flex-start: alinea el item en la parte superior.
align-self: flex-end: alinea el item en la parte inferior.
El espacio visible depende del contenido y del padding del item.


## Grid Basico

grid nos ayuda a posionar de mejor forma en los contenedores flex ayuda a comodar contenido y grid ayuda a comodar contenido en los contenedores

una fracccion es una unidad de medida unica de css grid

gap es el espacio que existe entre las columnas y filas

Con CSS Grid puedes posicionar contenido en dos ejes a la vez de forma clara y escalable. Activa el modelo con display: grid, define columnas con grid-template-columns usando fracciones fr, automatiza con la función repeat() y controla el espacio interno con gap. Verás un grid 2×2, cómo repartir 1fr 2fr 1fr, y cuándo preferir gap en lugar de margin.

¿Qué diferencia a grid de flexbox?
CSS Grid organiza elementos en columnas y filas simultáneamente, mientras que flexbox trabaja en un eje a la vez (horizontal o vertical). La clave es el contenedor padre: al aplicar display: grid, se activa el modelo de layout y los hijos se distribuyen en celdas.

Contenedor padre con display: grid activado.
Ejes doble: columnas y filas al mismo tiempo.
Control directo de proporciones con la unidad fr.
Idea fuerza: si buscas estructuras bidimensionales (p. ej., 2 columnas por varias filas), usa grid; si solo necesitas un eje, usa flexbox.

¿Cómo crear columnas con grid-template-columns y fracciones fr?
La unidad fr es exclusiva de Grid: representa una fracción del espacio disponible del contenedor. Con grid-template-columns defines cuántas columnas y qué proporción ocupa cada una. Por ejemplo, 1fr 1fr reparte el espacio en dos partes iguales; al añadir una tercera 1fr, tendrás tres columnas. Con cuatro elementos, se forma un grid dos por dos automáticamente.

¿Cómo definir un grid dos por dos?

    .grid.simple {
        display: grid;
        grid-template-columns: 1fr 1fr;
    }

    .item {
        background: #3498db;      /* azul del ejemplo */
        color: white;
        padding: 20px;
        text-align: center;
        margin: 3px;               /* visible, aunque con grid conviene usar gap */
    }

1fr 1fr: dos columnas del mismo tamaño.
Cuatro .item generan dos filas, formando el 2×2.
¿Cómo ajustar proporciones con 1fr, 2fr y 1fr?

    .grid.fraccion {
        display: grid;
        grid-template-columns: 1fr 2fr 1fr;
    }


La columna central ocupa el doble que las laterales.
Si cambias 2fr por 1fr, tendrás tres columnas iguales.
¿Cómo manejar el espacio con gap y la función repeat?
Para evitar repetir valores, la función repeat() simplifica la definición de columnas: repeat(3, 1fr) crea tres columnas iguales. Además, gap establece el espacio entre columnas y filas del grid sin modificar el tamaño interior de los elementos, a diferencia de margin.

    .grid.gap {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;  /* espacio entre columnas y filas */
    }

repeat(3, 1fr): código más limpio y fácil de mantener.
gap: 20px: separación clara entre celdas del grid.
Recomendación práctica: si ya usas grid, preferir gap sobre margin para separar elementos.

## Grid Avanzado

¿Cómo crear un layout con grid areas en CSS?
Con grid-template-areas defines un template visual del layout y con grid-area enlazas cada elemento. Así posicionas header, sidebar, content y footer sin cálculos complejos.

display: grid activa el modelo de cuadrícula.
grid-template-areas dibuja el layout con nombres de áreas.
grid-template-columns define anchos (ej: 200px y 1fr).
gap y margin-bottom mejoran la separación visual.
grid-area enlaza cada bloque con su área del template.
¿Cómo declarar el template de áreas?

    .grid-areas {
        display: grid;
        grid-template-areas:
            "header header"
            "sidebar content"
            "footer footer";
        grid-template-columns: 200px 1fr;
        gap: 10px;
        margin-bottom: 20px;
    }

/* Estilos base compartidos */
    header, .sidebar, .content, footer {
        padding: 20px;
        text-align: center;
        color: white;
    }

¿Cómo linkear elementos con grid area?
header { grid-area: header; background: #2ECC71; }
.sidebar { grid-area: sidebar; background: #E74C3C; }
.content { grid-area: content; background: #3498DB; }
footer { grid-area: footer; background: purple; }
header ocupa el 100% del ancho al repetirse en la fila: "header header".
sidebar queda a la izquierda y content a la derecha.
footer también ocupa el 100% con "footer footer".
Verifica que los nombres de clases coincidan (ej: .sidebar y no .bar).
¿Cuándo usar span para extender columnas en grid?
Cuando quieres que un ítem se extienda a través de varias columnas o filas consecutivas sin recalcular fracciones, usa span. Es directo y legible.

    .grid-span {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin-bottom: 20px;
    }

/* Extender un elemento por 2 columnas */

    .item--span-2 { 
     grid-column: span 2; 
    }

grid-column: span 2 extiende el elemento por dos columnas.
Alternativa más simple que ajustar muchas fracciones con 1fr.
Escalable para diseños con muchos elementos.
¿Qué son las grid lines y cómo posicionar por líneas?
Las grid lines son las líneas delimitadoras de columnas y filas. En lugar de pensar en fracciones o span, defines desde qué línea hasta cuál colocar el elemento, tanto en columnas como en filas.

    .grid-lines {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin-bottom: 20px;
    }

/* Posicionar por columnas: de la línea 1 a la 3 */

    .box-1 {
        grid-column: 1 / 3;
        background: red;
    }

/* Posicionar por filas: de la línea 1 a la 3 */

    .box-2 {
        grid-row: 1 / 3;
        background: green;
    }

Las líneas se cuentan desde el borde izquierdo/arriba hacia la derecha/abajo.
grid-column: 1 / 3 ocupa desde la línea 1 hasta la 3 (dos columnas de ancho).
grid-row: 1 / 3 ocupa desde la línea 1 hasta la 3 (dos filas de alto).
Útil cuando necesitas posiciones precisas sin depender de nombres de áreas o span.

## Media Queries    
    Cuando relizamos una pagina web en pc solemos solo ver la vista en web de pc pero, puede verse afectada cuando vemos en celulares o tablets y no puedes navegar en la pagina como lo harias en un pc a como lo harias en un dispositivo movil para poder navegar en la pagina web.

    movil fers: este principio se le dice que tenemos que mirar cuando tenemos que adaptar nuestra pagina web en celulares que antes de web de pc 

    Media query es como podemos jugar con los tamaños para ordenar el estilo para moviles, tablets y oordenadores

Responsive design: adaptar la UI al dispositivo para una buena lectura y navegación.
Mobile first: definir primero estilos base para móvil y escalar a tablet/desktop.
Viewport: ancho visible que guía cuándo activar cambios con media queries.
Accesibilidad con rem: tipografías que respetan ajustes del usuario.
Habilidades trabajadas: configurar flexbox, definir puntos de quiebre con min-width, gestionar visibilidad con display, depurar con el inspector del navegador.
¿Cómo aplicar media queries con flexbox paso a paso?
La estrategia es clara: estilos base para móvil y, con media queries, reacomodar layout y visibilidad según el tamaño del viewport. Se usan puntos de quiebre en 768 px para tablet y 1024 px para desktop.

¿Qué estilos base definen el modo mobile?
Contenedor en columna con separación y márgenes.
Tarjetas con color de fondo, contraste y padding.
Navegación vertical pensada para menú tipo hamburguesa.
Secciones de visibilidad: mostrar “mobile” y ocultar “tablet” y “desktop”.
Tipografías en rem: título y texto escalables.
/* Base: mobile first */
.container {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 20px;
}

.box {
  background: #3498DB;
  color: white;
  padding: 20px;
  text-align: center;
}

.nav {
  background: #2c3e50;
  margin-bottom: 20px;
}

.nav-list {
  list-style: none;
  display: flex;
  flex-direction: column;
}

.nav-list a {
  display: block;
  color: white;
  padding: 10px;
  text-decoration: none;
}

/* Visibilidad por dispositivo */
.visibility { margin-bottom: 20px; }
.mobile { background: red; color: white; padding: 10px; }
.tablet { display: none; }
.desktop { display: none; }

/* Tipografía base */
.responsive.title { font-size: 1.5rem; }
.responsive.text { font-size: 1rem; }
¿Qué cambia en tablet con min-width: 768px?
Reacomodo a fila con flex-direction: row.
Tarjetas que crecen con flex: 1.
Menú horizontal para aprovechar el ancho.
Mostrar contenedor “tablet” y ocultar “mobile”.
Título más grande con 2rem.
@media (min-width: 768px) {
  .container { flex-direction: row; }
  .box { flex: 1; }
  .nav-list { flex-direction: row; }

  .mobile { display: none; }
  .tablet {
    display: block;
    background: #F39C12;
    color: white;
    padding: 10px;
  }

  .responsive.title { font-size: 2rem; }
}
¿Qué cambia en desktop con min-width: 1024px?
Ocultar “tablet” y mostrar “desktop”.
Ajustar jerarquía tipográfica: título a 3rem y texto a 1.2rem.
@media (min-width: 1024px) {
  .tablet { display: none; }
  .desktop {
    display: block;
    background: green;
    color: white;
    padding: 10px;
  }

  .responsive.title { font-size: 3rem; }
  .responsive.text { font-size: 1.2rem; }
}
¿Qué ajustes de tipografía y visibilidad mejoran la experiencia?
El uso de rem permite que los tamaños de fuente se adapten al dispositivo y a las preferencias del usuario. Se definen escalas claras: 1.5rem en móvil, 2rem en tablet y 3rem en desktop para el título; el texto pasa de 1rem a 1.2rem en desktop. La visibilidad se controla con display: none/block para mostrar solo el bloque pertinente a cada tamaño.

Tipografía responsive con rem para accesibilidad.
Visibilidad por dispositivo: .mobile, .tablet, .desktop.
Flexbox para alternar entre columna y fila según espacio disponible.
Media queries con min-width en 768 px y 1024 px.
Prueba práctica: usar el inspector y observar el número del viewport al redimensionar.
Depuración común: verificar clases si un estilo no aplica por un error tipográfico.

## Diseño Fluido
Para conseguir un diseño fluido tenemos que agregar un diseño flexible con el media query 

---
La pantalla mas pequeña del mercado es 320px

El diseño fluido en CSS potencia el responsive design al hacer que el layout se adapte entre breakpoints. Con unidades relativas y funciones como porcentajes, vw, vh, rem y clamp, tu interfaz se mantiene flexible sin depender solo de media queries. Aquí verás cómo aplicar contenedores fluidos, grid adaptable, imágenes flexibles y tipografía responsiva.

¿Qué es diseño fluido y cómo complementa responsive design?
El enfoque fluido asegura que el layout se ajuste continuamente mientras se acerca a un breakpoint. No todas las pantallas se resuelven con media queries. Por eso, se usan medidas relativas para que el contenido se adapte al ancho y alto disponibles.

Porcentajes: ajustan tamaños según el contenedor padre.
Unidades de viewport: vw para ancho, vh para alto. Ocupan un porcentaje de la pantalla.
rem: escala con el tamaño de fuente base del documento.
Breakpoints: cambian estilos en puntos clave, pero el fluido suaviza la transición.
La combinación de estas unidades con flex y grid permite que el contenido fluya y mantenga legibilidad en móviles, tablets y desktop.

¿Cómo crear un contenedor fluido con width, max-width y min-width?
Un contenedor fluido usa porcentajes, límites mínimo y máximo, y centrado automático. Así controlas el crecimiento sin perder flexibilidad.

width: 90%: ocupa el 90% del padre.
max-width: 1000px: no crece más de 1000 px.
min-width: 320px: no se hace menor que 320 px (ancho móvil pequeño).
margin: 0 auto: centra el bloque cuando hay espacio sobrante.
padding y color de fondo: mejoran la lectura.

    .fluid-container {
        width: 90%;
        max-width: 1000px;
        min-width: 320px;
        margin: 0 auto;
        padding: 20px;
        background: blue;
        color: white;
    }

Claves prácticas: - Si el viewport baja de 320 px, aparece scroll horizontal. - Al superar 1000 px, el contenido queda centrado gracias a margin: 0 auto. - Entre 320 y 1000 px, el bloque usa siempre el 90% del contenedor padre.

¿Cómo aplicar grid, imágenes y texto fluido con clamp?
Para un layout flexible sin media queries, grid ofrece patrones adaptables y las imágenes y fuentes requieren reglas específicas para mantener foco y legibilidad.

¿Qué patrón de grid usar con repeat, auto-fit y minmax?
Con grid-template-columns y repeat(auto-fit, minmax()) logras columnas que se reacomodan según el espacio. El mínimo asegura legibilidad; el máximo reparte el espacio disponible con 1fr.

    .fluids-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
    }

auto-fit: ajusta el número de columnas según el ancho disponible.
minmax(250px, 1fr): cada tarjeta mide mínimo 250 px y crece equitativamente.
gap: separa elementos y mejora el ritmo visual.
¿Cómo hacer una imagen flexible dentro de su contenedor?
Primero, limita el contenedor con max-width y céntralo. Luego, haz que la caja de imagen ocupe el 100% del ancho y define una altura para que sea visible.

    .image-contained {
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
    }

    .image-box {
        width: 100%;
        height: 200px;
        background: red;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
    }

Buenas prácticas: - Define altura para evitar colapsos visuales. - Considera el encuadre: en headers, prioriza la zona visible relevante. - Si luego usas imágenes reales, combina con object-fit y object-position según el caso.

¿Cómo escalar tipografía con la función clamp?
La función clamp() define un mínimo, un valor ideal relativo y un máximo. Así el texto crece suave con el viewport y se detiene donde conviene.

    .fluid-title {
        font-size: clamp(1.5rem, 4vw, 3rem);
        margin-bottom: 10px;
    }

Mínimo: 1.5rem para móviles.
Ideal relativo: 4vw para crecer con el ancho.
Máximo: 3rem para desktop grandes.
Ventajas clave: - Legibilidad constante sin saltos bruscos. - Una sola regla cubre móviles, tablets y desktop.

## Mobile First
    las mejores practicas para nuestrso proyectos responsive 

    rendimeinto performance primero: hacer un que nuestra pagina web tenga rendimiento adecuado para movil para tablet y pc 

    contenido prioritario: este contenido tiene que ser el mas esencial para los dispositivos moviles 

    touch friendly: hacer que nuestro dedo pueda darle correctamente a la pantalla para que el ususario se sienta comodo en la pagina.

    navegacion progresiva: segun vallas navegando se va acomodando nuestra pagina a el dispositivo

    Hero section progresiva: hacer un cambio en nuestro layaout de nuestro contenido.

    Grid Cards Progresivo: podemos hacer que nuestro grid tambien sea responsivo y juagar con os tamaños de la pantalla

    fuentes size: utilizar siempre rem para el responsive de una pagina para relizar un responsive adecuado 

Cargar solo lo esencial en mobile. Enfócate en lo que el usuario necesita ver y hacer primero.

Priorizar el contenido. Define el objetivo clave y muéstralo sin distracciones.

Aplicar mejoras progresivas. Agrega características según las capacidades reales de los dispositivos de tus usuarios.
Ajustar por dispositivo. Comprende qué usan tus usuarios y adapta características que puedan soportar.

¿Qué patrones de navegación y hero mejoran la 
experiencia mobile?

Cuando el espacio se compromete, la navegación debe simplificarse. La idea es reducir ruido visual y permitir acceso rápido a lo importante. Lo mismo ocurre con secciones visuales como el hero.

¿Cómo manejar la navegación progresiva?

Usar icono de hamburguesa cuando el espacio se reduce.
Alternar visibilidad con CSS y JavaScript: display: none / display: block.
Quitar “basura” visual en pantallas pequeñas y dejar solo lo necesario para interactuar.

¿Cómo adaptar el hero por tamaño de pantalla?

Cambiar el layout con grid o flex según el espacio disponible.
Si en mobile la imagen del hero no aporta al objetivo, se puede omitir.
Mantener siempre visible el contenido clave con el que el usuario interactúa.

¿Cómo adaptar cartas y formularios con CSS flexible?

El contenido debe fluir y reacomodarse según el ancho. Las cartas y los formularios son grandes candidatos para layouts que cambian cuando hay espacio suficiente.

Hacer contenido flexible. Reacomoda cartas según el tamaño y cambia el layout cuando el ancho lo permita.
Formularios adaptables. En pantallas amplias pueden ir campos lado a lado; en mobile, conviene columna para evitar toques fallidos.
Cuidar el espacio entre inputs. Aumenta márgenes y separaciones para mejorar la interacción táctil.

¿Qué tamaños y espaciados touch garantizan buena usabilidad?

Touch targets: área mínima de 44 x 44 px para botones y elementos interactivos.
Fuentes: mínimo de 6 px (1 rem) para asegurar legibilidad.
Saltos de línea: 1.6 de interlineado para lectura cómoda en bloques de texto extensos.

¿Tienes dudas o un caso real que quieras optimizar? Comparte tu escenario y comentamos cómo priorizar, maquetar y ajustar interacciones para mobile y más allá.

## Transformaciones
    Las transformaciones en CSS nos permiten cambiar la forma, tamaño, posición o inclinación de un elemento sin afectar el resto de la página, con ellas podemos rotar, escalar, mover o inclinar objetos de manera muy visual y dinámica. Además, se pueden combinar varias transformaciones a la vez para crear efectos más llamativos.

    .container{
    display: flex;
    gap: 30px;
    margin-bottom: 40px;
    padding: 20px;
    background: #f0f0f0;
    }

    .box{
        width: 100px;
        height: 100px;
        background: #3498db;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.3s; 
    }

    .translate-x:hover{
        transform: translateX(30px);
    }

    .translate-y:hover{
        transform: translateY(-30px);
    }

    .translate-xy:hover{
        transform: translate(20px, 20px)    ;
    }   

    .rotate-45:hover{
        transform: rotate(45deg);
    }

    .scale-small:hover{
        transform: scale(0.5);
    }

## Transiciones 
    ¿Por qué usar transiciones en CSS?
Las transiciones hacen que los cambios se sientan suaves y naturales. Evitan saltos abruptos al pasar el hover y aportan claridad visual.

Suavizar color de fondo con background-color en 0.3s.
Escalar elementos con transform: scale para dar feedback.
Mover en el eje X con translateX y controlar el tiempo.
Acompañar el movimiento con box-shadow para dar profundidad.
¿Qué estilos base necesitas en los botones?
Primero se definen estilos base para separación y legibilidad. Usa display: flex, gap y margin-bottom.

/* Contenedor de botones */

    .buttons {
        display: flex;
        gap: 12px;
        margin-bottom: 40px;
    }

/* Botón base */

    .button {
        padding: 12px 24px;
        font-size: 16px; /* o 1rem */
        cursor: pointer;
        background: #3498DB;
        color: #fff;
        border: 0;
    }

¿Cómo aplicar transiciones en botones con hover?
La clave está en declarar la propiedad a animar, la duración y la función de aceleración. Así, el cambio no se ve brusco.

¿Cómo suavizar el cambio de color?
Para que el color de fondo cambie de forma fluida con hover, anima background-color.

/* Transición del color de fondo */
    .button-color {
        transition: background-color 0.3s ease;
    }

    .button-color:hover {
        background-color: #E74C3C; /* rojo suave */
    }

¿Cómo hacer que el botón crezca?
Si buscas un efecto de crecimiento, anima transform con scale.

/* Transición de tamaño */
    .button-size {
        transition: transform 0.3s ease;
    }

    .button-size:hover {
        transform: scale(1.1);
    }

¿Cómo combinar color, sombra y escala en un botón?
Cuando un mismo elemento cambia varias propiedades, puedes usar all para cubrirlas. Evita declarar múltiples transform separados.

/* Botón con varios cambios al hover */
    .button-all {
        transition: all 0.3s ease;
    }

    .button-all:hover {
        background-color: #2ECC71; /* verde */
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        transform: scale(1.1); /* se decidió escalar y no         trasladar */
    }

¿Cómo depurar conflictos con transform y la cascada?
No declares dos reglas de transform en el mismo selector al mismo tiempo: una pisará a la otra.
Si necesitas combinar, usa un solo transform: por ejemplo, transform: translateY(-5px) scale(1.1);.
Usa las herramientas del navegador: fuerza el hover en el inspector y revisa qué reglas están activas.
¿Cómo controlar el timing con linear, ease y ease-in-out?
El tiempo y la aceleración definen la sensación del movimiento. Con transform y transition puedes mover una caja 200px a la derecha y ver cómo varía la velocidad según linear, ease y ease-in-out.

/* Contenedor de ejemplos de timing */
        .timing-container {
        display: flex;
        gap: 20px;
        margin-bottom: 40px;
    }

/* Caja base */
    .box {
        width: 100px;
        height: 100px;
        background: #9B59B6; /* morado */
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
    }

/* Variantes de timing */
    .timing-linear { transition: transform 1s linear; }
    .timing-ease { transition: transform 1s ease; }
    .timing-ease-in-out { transition: transform 1s ease-in-out; }

/* Disparador común */
    .box:hover { transform: translateX(200px); }
    linear: velocidad uniforme todo el tiempo.
    ease: aceleración natural, empieza lento y acelera.
    ease-in-out: suave al inicio y al final, rápido en medio.
    Consejos rápidos: - Define claramente la propiedad: background-color o transform, según el efecto. - Ajusta la duración: 0.3s para hover en UI se siente fluido. - Usa box-shadow para reforzar la sensación de elevación. - Evita conflictos: un único transform por selector al final de la cascada.

## Transiciones aplicadas

¿Cómo crear una card con transiciones CSS consistentes?
Para una base sólida se define un contenedor con ancho fijo, espaciado interno y bordes suaves. Lo clave: una transición uniforme para todas las propiedades que cambiarán, manteniendo la misma duración y timing function para que se sienta natural.

    .card {
        width: 300px;
        padding: 30px;
        background: white;
        border: 2px solid #ecf0f1; /* gris claro */
        border-radius: 10px;
        cursor: pointer;
        transition: transform .3s ease, box-shadow .3s ease,  border-color .3s ease;
    }

width: 300px para controlar la composición.
padding: 30px para espacio interno legible.
border: 2px y border-radius: 10px para un contorno suave.
transition de .3s en transform, box-shadow y border-color para coherencia.

¿Qué conceptos aplicas al definir la base?
Uso de cursor: pointer para indicar interactividad.
Transición con ease para un movimiento suave.
Separación de propiedades en la transition para claridad y control.

¿Qué efectos aplicar con hover para mejorar la interacción?
Al pasar el puntero, la tarjeta se eleva con translate, gana profundidad con box-shadow y refuerza el foco con el cambio de color del borde a azul. Todo a la misma velocidad para evitar desajustes visuales.

    .card:hover {
        transform: translateY(-10px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, .2);
        border-color: #3498db;
    }

transform: translateY(-10px) para elevar la tarjeta.
box-shadow: 0 10px 30px rgba(0,0,0,.2) para profundidad.
border-color azul para contraste y foco.
¿Por qué mantener la misma duración en transition?
Asegura una percepción fluida del cambio.
Evita saltos entre propiedades que distraen.
Refuerza la consistencia del movimiento.
¿Cómo estilizar el contenido: títulos y párrafos con transición?
El contenido interno también comunica. El título cambia de color al hover y el párrafo se desplaza con un pequeño delay para entrar en escena después de la tarjeta.

    .card h3 {
        color: #2c3e50; /* gris oscuro */
        margin-bottom: 10px;
        transition: color .3s ease;
    }

    .card h3:hover {
        color: #3498db;
    }

    .card p {
        color: #7f8c8d; /* gris */
        transition: transform .3s ease .1s; /* delay de 0.1s */
    }

    .card:hover p {
        transform: translateX(10px);
    }

H3 con color #2c3e50 y margen inferior de 10px para 
separación.

transition: color .3s ease en el título para un cambio suave.

Párrafo con transition en transform y delay de 0.1s para entrar después.
translateX(10px) en el texto al hover de la card, no del 
párrafo: se activa desde el contenedor.

¿Qué habilidades y keywords refuerzas aquí?
Manejo de transiciones CSS: transition, duración y timing 
function.

Transformaciones con translate en ejes X/Y.
Sombras con box-shadow y opacidad RGBA.
Estados interactivos con hover en contenedor y en elementos internos.

Jerarquía temporal con delay para escalonar animaciones.
¿Te animas a aplicar estos patrones en tu UI? Cuenta cómo vas a combinar transform y box-shadow, o qué delay te funciona mejor en títulos y textos.


## Animaciones

    ¿Cómo funcionan las animaciones en CSS y en qué se diferencian de las transiciones?
A diferencia de las transiciones, que necesitan un trigger (por ejemplo, hover), las animaciones se ejecutan por sí mismas al declararlas con keyframes y aplicarlas con la propiedad animation. No hay eventos adicionales: el ciclo inicia y se repite según lo configurado.

@keyframes define estados en 0 %, intermedios y 100 %.
animation controla nombre, duración, curva de tiempo y repetición.
transform aplica efectos como scale, rotate y translateY.
Timing functions: ease-in-out suaviza inicio y final; linear mantiene velocidad constante.
Repetición: infinite mantiene la animación corriendo sin parar.
Asegúrate de escribir keyframes en plural: evita errores de sintaxis.
¿Cómo implementar animaciones pulse, rotate y bounce con keyframes?
Antes de animar, se define un estilo base del contenedor .box: tamaño, color y centrado del contenido con flex para ver claramente los efectos.

.box {
  width: 100px;
  height: 100px;
  background: #3498DB;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 20px;
  border-radius: 10px;
}
¿Cómo crear un efecto pulse con transform: scale?
El elemento crece al 50 % del tiempo y vuelve a su tamaño original.

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
}

.box.pulse {
  animation: pulse 2s ease-in-out infinite;
}
scale(1.2): aumento aproximado del 20 % del tamaño.
ease-in-out: entrada y salida suaves.
infinite: se repite continuamente.
¿Cómo rotar con rotate en una animación continua?
Gira 360 grados y repite sin fin con una velocidad constante.

@keyframes rotate {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.box.rotate {
  animation: rotate 3s linear infinite;
}
linear: velocidad uniforme durante todo el ciclo.
360deg: vuelta completa.
¿Cómo simular un rebote con translateY?
Usa varios frames para subir y bajar en pasos decrecientes.

@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  25% { transform: translateY(-30px); }
  50% { transform: translateY(-15px); }
  75% { transform: translateY(-5px); }
}

.box.bounce {
  animation: bounce 2s ease infinite;
}
Secuencia con 0 %, 25 %, 50 %, 75 % y 100 %.
translateY negativo: simula la subida del salto.
Pasos decrecientes: sensación de amortiguación.
¿Cómo crear un spinner de loading solo con CSS?
Un anillo con borde superior coloreado que rota de forma continua. Ideal para indicar carga hasta que con JavaScript ocultes el spinner y muestres el contenido.

.spinner {
  width: 50px;
  height: 50px;
  border: 5px solid #f3f3f3;
  border-top: 5px solid #3498DB;
  border-radius: 50%;
  margin: 20px;
  animation: spin 1s linear infinite;
}

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

border-top coloreado: crea el efecto de giro visible.
1s linear infinite: giro constante y fluido.
50% de border-radius: círculo perfecto.
¿Te gustaría que revisemos tu código y afinemos tiempos, curvas o clases para tu caso específico? Comparte tus dudas y ejemplos en los comentarios.
